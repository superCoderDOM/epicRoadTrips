/*
Based on Randy Olson's Shortest Route Program, as modified By Andrew Liesinger to:
    1: Detect waypoints file at runtime - if found use it, otherwise look up distances via google calls (and then save to waypoint file)
    2: Dynamically create and open an HTML file showing the route when a shorter route is found
    3: Make it easier to tinker with the Generation / Population parameters
*/

// required npm packages
const env = require('../.env');
const moment = require('moment');
const mongoose = require('mongoose');
const testCases = require('../tests/roadtrip-testdata');

// Import required MongoDB models
const DistanceMatrix = require('../../models/DistanceMatrix');
const EpicRoadTrip = require('../../models/EpicRoadTrips');

// // Define MongoDB Connection settings
// const MONGO_CONNECTION_STRING = 'mongodb://localhost:27017/data/db';

// // Start MongoDB server
// mongoose.connect(MONGO_CONNECTION_STRING);
// const connection = mongoose.connection;
// connection.on('open', () => { 
//     console.log('We are connected to mongo ^_^');
// });

// Initialize Google Maps Client
const googleMapsClient = require('@google/maps') // initialize Google Maps client
.createClient({
    key: env.GOOGLE_MAPS_API_KEY,
    Promise: Promise
});

// Parameters for the Genetic algorithm, 'Generations' and 'Population Size' must be a multiple of 10
const thisRunGenerations = 1000;
const thisRunPopulation_size = 100;

// Parameters for the Google Maps Distance Matrix search
const mode = "driving"; // options include: "driving", "walking", "bicycling", and "transit"
const language  = "English";
const units     = "metric";

/*=============================
    CODE TESTING PARAMETERS
=============================*/

// Test Epic Road Trip: Top National Park/Monument/Site in each US State
const devTesting = false;
const waypointDistanceMatrix_id = ""; // "5a1ccab0e964fe6682caf979"; // "5a189bdf1dad300ba0f0175e";
// const allWaypoints = testCases.US_Top50_NatnlSites;

// Call optimalRoute as server would do
// optimalRoute(allWaypoints, mode)
// .then(epicRoadTrip => {
//     console.log("Epic Road Trip:", epicRoadTrip);
//     writeEpicRoadTrip(epicRoadTrip);
//     return epicRoadTrip;
// })
// .catch(error => {
//     console.log(error);
// });

/*=============================================================
    PRIMARY FUNCTION CALLED BY SERVER TO FIND OPTIMAL ROUTE
=============================================================*/

function optimalRoute(allWaypoints, mode){
    /*
        This function generates the data required to compute the optimal route between all waypoints
        The optimal road trip meets the following criteria:
          - travels the least distance TO...
          - visit all waypoints supplied AND...
          - return to its starting point

        Travel distances are generated by calling the Google Maps Distance Matrix API hundreds of times to obtain
        the optimal distance and duration of a trip between each possible pairs of waypoints
    */
        
    // Collect data by asking GoogleMaps Distance Matrix API
    console.log("Begin finding shortest route")
    
    let waypointList = [];
    let waypointDistanceMatrix = [];
    let optimalRoadTrip;
    
    if (devTesting && waypointDistanceMatrix_id){ // in development and waypointDistanceMatrix_id is provided
        console.log('Skipping Google Maps calls');

        // find all 'DistanceMatrix' documents
        optimalRoadTrip = DistanceMatrix.findById(waypointDistanceMatrix_id)
        .then(reqDistanceMatrix => {

            for (let i = 0; i < reqDistanceMatrix.distance_matrix.length; i++){
                waypointDistanceMatrix.push({
                    waypoint1: reqDistanceMatrix.distance_matrix[i].waypoint1,
                    waypoint2: reqDistanceMatrix.distance_matrix[i].waypoint2,
                    distance_m: reqDistanceMatrix.distance_matrix[i].distance_m,
                    duration_s: reqDistanceMatrix.distance_matrix[i].duration_s,
                });
                waypointList = [...waypointList, reqDistanceMatrix.distance_matrix[i].waypoint1, reqDistanceMatrix.distance_matrix[i].waypoint2];
            }
            waypointList = [...new Set(waypointList)];
            // console.log(reqDistanceMatrix.distance_matrix);
            console.log("Searching for optimal route");            
            return runGeneticAlgorithm(thisRunGenerations, thisRunPopulation_size, waypointList, waypointDistanceMatrix);        
        })
        .then(bestSolution => {
            // console.log("Best:", bestSolution);
            return bestSolution;
        })
        .catch(error => {
            console.log(error);
            return error;
        });

    }else{
        const googlePromises = [];

        // Create a googleMaps promise for each possible unique combination of waypoints
        combinations(allWaypoints, 2).forEach((waypointSet, index) => {                
            const waypoint1 = waypointSet[0];
            const waypoint2 = waypointSet[1];

            let newP = new Promise((resolve, reject) => {
                function makeAPICall(){
                    googleMapsClient.distanceMatrix({
                        origins: waypoint1,
                        destinations: waypoint2,
                        mode: mode, // e.g.: "driving", "walking", "bicycling"
                        language: language,
                        units: units,
                    })
                    .asPromise()
                    .then(route => {
                        waypointDistanceMatrix.push({
                            waypoint1: route.json.origin_addresses[0],
                            waypoint2: route.json.destination_addresses[0],
                            distance_m: parseInt(route.json.rows[0].elements[0].distance.value),
                            duration_s: parseInt(route.json.rows[0].elements[0].duration.value),
                        });
                        console.log(`Done promise ${index}:\nFrom: ${waypoint1}\nTo:   ${waypoint2}`);
                        resolve(route);
                    })
                    .catch(error => {
                        reject(error);
                    });
                }
                // setting a timeout within the promise
                setTimeout(makeAPICall, 100*index);        
            });
            // push the promise into the array
            googlePromises.push(newP);
        });
        
        optimalRoadTrip = Promise.all(googlePromises)
        .then(routes => {
            // console.log(routes, "All promises fullfilled");

            // create list of all waypoints names as returned by Google Maps API search
            for (let i = 0; i < routes.length; i++){                
                waypointList = [...waypointList, routes[i].json.origin_addresses[0], routes[i].json.destination_addresses[0]];
            }
            waypointList = [...new Set(waypointList)];

            // if in development, save results to database
            if (devTesting){
                writeDistanceMatrix(waypointDistanceMatrix);
            }
        
            console.log("Searching for optimal route");
            return runGeneticAlgorithm(thisRunGenerations, thisRunPopulation_size, waypointList, waypointDistanceMatrix);
        })
        .then(bestSolution => {
            // console.log("Best:", bestSolution);
            return bestSolution;
        })
        .catch(error => {
            writeDistanceMatrix(waypointDistanceMatrix);            
            console.log(error);
            return error;
        });
    }
    return optimalRoadTrip;
}

/*=============================================
    CORE FUNCTION OF THE GENETIC ALGORITHM
=============================================*/
    
async function runGeneticAlgorithm(generations = thisRunGenerations, populationSize = thisRunPopulation_size, waypointList, waypointDistanceMatrix){
    /*
        The core of the Genetic Algorithm
        Parameters 'generations' and 'populationSize' must be a multiple of 10
    */

    try {

        // console.log(waypointDistanceMatrix);
        console.log("Start genetic algorithm");

        let currentBestDistance = -1;
        let currentBestRoadTrip = [];
        const populationSubsetSize = Math.floor(populationSize / 10);
        const generations10pct = Math.floor(generations / 10);
        
        // Create a random population of 'populationSize' number of solutions
        let population = await generateRandomRoadTripPopulation(waypointList, populationSize); // population is an array of array
        // console.log(population);

        // For 'generations' number of repetitions...
        for (let generation = 0; generation < generations; generation++){

            // console.log("Generation:", generation, "Population size:", population.length);

            // Initialize fitness evaluation of current population
            let populationRoadTripDistance = [];

            // Compute fitness of each road trip in current population
            for (let count = 0; count < population.length; count++){

                let testRoadTrip = population[count];

                // Evaluate fitness only if current road trip is NOT a duplicate
                if (populationRoadTripDistance.indexOf(testRoadTrip) < 0){

                    let [totalTripDistance, totalTripDuration] = await computeDistance(testRoadTrip, waypointDistanceMatrix); // evaluates total distance covered by road trip

                    populationRoadTripDistance.push({
                        testRoadTrip: testRoadTrip,
                        totalTripDistance: totalTripDistance,
                        totalTripDuration: totalTripDuration,
                    });
                }
                // console.log(populationRoadTripDistance[count].testRoadTrip, populationRoadTripDistance[count].totalTripDistance);
            }

            // Sort populationRoadTripDistance by totalTripDistance (shortest distance travelled first)
            const populationSortedByDistance = Array.from(populationRoadTripDistance).sort((testRoadTrip1, testRoadTrip2) => {
                return testRoadTrip1.totalTripDistance - testRoadTrip2.totalTripDistance;
            });

            // Select and keep only best 10 percent of routes created
            const populationBest10pct = populationSortedByDistance.slice(0, populationSubsetSize);

            // Initialize next generation
            let newPopulation = [];
            
            // Produce offsprings of top routes created
            for (let rank = 0; rank < populationBest10pct.length; rank++){

                // Check on best solution at every 10th percentile and on second-last generations
                if ((generation % generations10pct === 0 || generation === generations - 1) && rank === 0){

                    currentBestRoadTrip = populationBest10pct[rank];
                    console.log(`Generation ${generation} best: ${currentBestRoadTrip.totalTripDistance} | Unique genomes: ${populationRoadTripDistance.length}`); // \n${currentBestRoadTrip.testRoadTrip}

                    // If this is the first route found, or it is shorter than the best route we know,
                    // create a html output and display it
                    if (populationBest10pct[rank].totalTripDistance < currentBestDistance || currentBestDistance < 0){
                        currentBestDistance = populationBest10pct[rank].totalTripDistance;
                    }
                }

                // Create 1 exact copy of each of the top road trips
                newPopulation = [...newPopulation, populationBest10pct[rank].testRoadTrip];

                // Create 2 offspring with 1-3 point mutations
                for (let offspring = 0; offspring < 2; offspring++){
                    newPopulation = [...newPopulation, await mutateAgent(populationBest10pct[rank].testRoadTrip, 3)];
                }    
                // Create 7 offspring with a single shuffle mutation
                for (let offspring = 0; offspring < 7; offspring++){
                    newPopulation = [...newPopulation, await shuffleMutation(populationBest10pct[rank].testRoadTrip)];
                }
            }
            // Replace the old population with the new population of offspring 
            population = [...newPopulation];
        }

        return currentBestRoadTrip;
    }
    catch (error){

        return error;
    }
}

/*==================================
    ALL OTHER REQUIRED FUNCTIONS
==================================*/

function combinations(setToCombine, groupingSize) {
	var groupedSet, setHead, setTail;
	
	// Required grouping size is larger than set of elements
	if (groupingSize > setToCombine.length || groupingSize <= 0) {
		return [];
	}
	
	// Grouped set has only one subset
	if (groupingSize === setToCombine.length) {
		return [setToCombine];
	}
	
	// Grouped set is a single element, creates copy of original set
	if (groupingSize === 1) {
		groupedSet = [];
		for (let i = 0; i < setToCombine.length; i++) {
			groupedSet.push([setToCombine[i]]);
		}
		return groupedSet;
	}
	
	// Main use case: assert {1 < groupingSize < setToCombine.length}
	groupedSet = [];
	for (let i = 0; i < setToCombine.length - groupingSize + 1; i++) {
		// setHead is a list that includes only our current element
		setHead = setToCombine.slice(i, i + 1);
		// setTail is a list of unique combinations of the subsequent elements
		setTail = combinations(setToCombine.slice(i + 1), groupingSize - 1);
		// For each combination we join it with the current
		// and store it to the set of groupingSize-combinations
		for (let j = 0; j < setTail.length; j++) {
			groupedSet.push(setHead.concat(setTail[j]));
		}
	}
	return groupedSet;
}

function shuffle(array){
    /*
        This function returns an array with the same items as in the original array
        BUT randomly shuffled into new positions
    */

    let shuffledArray = Array.from(array);

    for (let i = array.length - 1; i > 0; i--){
        let j = Math.floor(Math.random() * (i + 1));
        [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
    }

    return shuffledArray;
}

function computeDistance(testRoadTrip, waypointDistanceMatrix){ //
    /*
        Find the total distance traveled by the road trip visiting waypoints in the current order
        The genetic algorithm favours road trips that have shorter total distances traveled
    */

    let roadTripDistance = 0;
    let roadTripDuration = 0;
    
    // loop over road trip and grap each pair of waypoints
    for (let i = 0; i < testRoadTrip.length; i++){

        let waypoint1 = (i > 0) ? testRoadTrip[i - 1] : testRoadTrip[testRoadTrip.length - 1]; // at index 0, we grab first and last waypoints in list
        let waypoint2 = testRoadTrip[i];

        // find data associated with current waypoint pair
        let tripSegmentData = waypointDistanceMatrix.find(tripSegment => (tripSegment.waypoint1 === waypoint1 && tripSegment.waypoint2 === waypoint2) || (tripSegment.waypoint1 === waypoint2 && tripSegment.waypoint2 === waypoint1));
        
        if(!tripSegmentData){
            console.log(testRoadTrip);
            console.log(waypoint1, "|", waypoint2);
            console.log(tripSegmentData);
        }

        // add distance between waypoints to total distance
        roadTripDistance += tripSegmentData.distance_m;
        roadTripDuration += tripSegmentData.duration_s;
    }

    return [roadTripDistance, roadTripDuration];
}

function generateTestRoadTrip(waypointList){
    /*
        Randomize/shuffle the order of road trip waypoints
    */

    let newTestRoadTrip = shuffle(waypointList);

    return newTestRoadTrip;
}

function mutateAgent(testRoadTrip, maxMutations = 3){
    /*
        Apply single 'maxMutations' point mutations to the given set of road trip waypoints      
          - A point mutation swaps the order of two waypoints in the road trip
    */

    let mutatedRoadTrip = Array.from(testRoadTrip);

    const numMutations = Math.ceil(Math.random() * maxMutations); // returns 1 <= numMutations <= maxMutations
    
    for (let mutation = 0; mutation < numMutations; mutation++){
        let swapIndex1 = Math.floor(Math.random() * mutatedRoadTrip.length); // returns 0 <= swapIndex <= (mutatedRoadTrip.length - 1)
        let swapIndex2 = swapIndex1;

        while (swapIndex1 === swapIndex2){
            swapIndex2 = Math.floor(Math.random() * mutatedRoadTrip.length); // returns 0 <= swapIndex <= (mutatedRoadTrip.length - 1)
        }

        [mutatedRoadTrip[swapIndex1], mutatedRoadTrip[swapIndex2]] = [mutatedRoadTrip[swapIndex2], mutatedRoadTrip[swapIndex1]];
    }

    return mutatedRoadTrip;
}

function shuffleMutation(testRoadTrip){
    /*
        Apply a single shuffle mutation to the given road trip waypoint array
          - A shuffle mutation takes a random sub-section of the road trip
            and moves it to another location in the road trip
    */

    let shuffledRoadTrip = Array.from(testRoadTrip);

    let startIndex = Math.floor(Math.random() * shuffledRoadTrip.length); // returns 0 <= startIndex <= (shuffledRoadTrip.length - 1)
    let length = Math.floor(Math.random() * 19) + 2; // returns 2 <= length <= 20
    
    const roadtripSubset = shuffledRoadTrip.slice(startIndex, startIndex + length);
    shuffledRoadTrip = [...shuffledRoadTrip.slice(0, startIndex), ...shuffledRoadTrip.slice(startIndex + length)];
    
    let insertIndex = Math.floor(Math.random() * (shuffledRoadTrip.length + shuffledRoadTrip.length)); // returns 0 <= insertIndex <= (shuffledRoadTrip.length + roadtripSubset.length - 1)
    shuffledRoadTrip = [...shuffledRoadTrip.slice(0, insertIndex), ...roadtripSubset, ...shuffledRoadTrip.slice(insertIndex)];

    return shuffledRoadTrip;
}

function generateRandomRoadTripPopulation(waypointList, populationSize){
    /*
        Generates an array with 'populationSize' number of randomly ordered road trip waypoint arrays
    */

    let randomRoadTripPopulation = [];
    for (let agent = 0; agent < populationSize; agent++){
        
        randomRoadTripPopulation.push(generateTestRoadTrip(waypointList));
    }
    
    return randomRoadTripPopulation;
}

/*==============================================================================================
    CONNECT TO MONGODB TO SAVE GOOGLE RESULTS WHILE IN DEVELOPMENT TO AVOID EXCEEDING QUOTAS
==============================================================================================*/

function writeDistanceMatrix(waypointDistanceMatrix){

    console.log("Saving distance matrix to database");

    // create new 'DistanceMatrix' document
    DistanceMatrix({ 
        distance_matrix: waypointDistanceMatrix,
        created: moment(),
        updated: moment(),
    })
    .save()
    .then(result => {
        return result;
    })
    .catch(error => {
        console.log(error);
    });
}

function writeEpicRoadTrip(epicRoadTrip){
    
        console.log("Saving epic road trip to database");
    
        // create new 'DistanceMatrix' document
        EpicRoadTrip({
            epicRoadTrip: epicRoadTrip.testRoadTrip,
            totalTripDistance: epicRoadTrip.totalTripDistance,
            totalTripDuration: epicRoadTrip.totalTripDuration,
            created: moment(),
            updated: moment(),
        })
        .save()
        .then(result => {
            return result;
        })
        .catch(error => {
            console.log(error);
        });
    }

// function readDistanceMatrix(waypointDistanceMatrix_id){
//     // find all 'DistanceMatrix' documents
//     DistanceMatrix.findById(waypointDistanceMatrix_id)
//     .then(reqDistanceMatrix => {
//         console.log(reqDistanceMatrix.distance_matrix);
//         return reqDistanceMatrix.distance_matrix;
//     })
//     .catch(error => {
//         return console.log(error);
//     });
// }

module.exports = {
    optimalRoute: optimalRoute,
    writeDistanceMatrix: writeDistanceMatrix,
    writeEpicRoadTrip: writeEpicRoadTrip,
}